// Code generated by protoc-gen-go. DO NOT EDIT.
// source: intoto.proto

package intoto_go_proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// This contains the fields corresponding to the definition of a software supply
// chain step in an in-toto layout. This information goes into a Grafeas note.
type InToto struct {
	// This field identifies the name of the step in the supply chain.
	StepName string `protobuf:"bytes,1,opt,name=step_name,json=stepName,proto3" json:"step_name,omitempty"`
	// This field contains the public keys that can be used to verify the
	// signatures on the step metadata.
	SigningKeys []*SigningKey `protobuf:"bytes,2,rep,name=signing_keys,json=signingKeys,proto3" json:"signing_keys,omitempty"`
	// The following fields contain in-toto artifact rules identifying the
	// artifacts that enter this supply chain step, and exit the supply chain
	// step, i.e. materials and products of the step.
	ExpectedMaterials []*InToto_ArtifactRule `protobuf:"bytes,3,rep,name=expected_materials,json=expectedMaterials,proto3" json:"expected_materials,omitempty"`
	ExpectedProducts  []*InToto_ArtifactRule `protobuf:"bytes,4,rep,name=expected_products,json=expectedProducts,proto3" json:"expected_products,omitempty"`
	// This field contains the expected command used to perform the step.
	ExpectedCommand []string `protobuf:"bytes,5,rep,name=expected_command,json=expectedCommand,proto3" json:"expected_command,omitempty"`
	// This field contains a value that indicates the minimum number of keys that
	// need to be used to sign the step's in-toto link.
	Threshold            int64    `protobuf:"varint,6,opt,name=threshold,proto3" json:"threshold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InToto) Reset()         { *m = InToto{} }
func (m *InToto) String() string { return proto.CompactTextString(m) }
func (*InToto) ProtoMessage()    {}
func (*InToto) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{0}
}

func (m *InToto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InToto.Unmarshal(m, b)
}
func (m *InToto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InToto.Marshal(b, m, deterministic)
}
func (m *InToto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InToto.Merge(m, src)
}
func (m *InToto) XXX_Size() int {
	return xxx_messageInfo_InToto.Size(m)
}
func (m *InToto) XXX_DiscardUnknown() {
	xxx_messageInfo_InToto.DiscardUnknown(m)
}

var xxx_messageInfo_InToto proto.InternalMessageInfo

func (m *InToto) GetStepName() string {
	if m != nil {
		return m.StepName
	}
	return ""
}

func (m *InToto) GetSigningKeys() []*SigningKey {
	if m != nil {
		return m.SigningKeys
	}
	return nil
}

func (m *InToto) GetExpectedMaterials() []*InToto_ArtifactRule {
	if m != nil {
		return m.ExpectedMaterials
	}
	return nil
}

func (m *InToto) GetExpectedProducts() []*InToto_ArtifactRule {
	if m != nil {
		return m.ExpectedProducts
	}
	return nil
}

func (m *InToto) GetExpectedCommand() []string {
	if m != nil {
		return m.ExpectedCommand
	}
	return nil
}

func (m *InToto) GetThreshold() int64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// Defines an object to declare an in-toto artifact rule
type InToto_ArtifactRule struct {
	ArtifactRule         []string `protobuf:"bytes,1,rep,name=artifact_rule,json=artifactRule,proto3" json:"artifact_rule,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InToto_ArtifactRule) Reset()         { *m = InToto_ArtifactRule{} }
func (m *InToto_ArtifactRule) String() string { return proto.CompactTextString(m) }
func (*InToto_ArtifactRule) ProtoMessage()    {}
func (*InToto_ArtifactRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{0, 0}
}

func (m *InToto_ArtifactRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InToto_ArtifactRule.Unmarshal(m, b)
}
func (m *InToto_ArtifactRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InToto_ArtifactRule.Marshal(b, m, deterministic)
}
func (m *InToto_ArtifactRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InToto_ArtifactRule.Merge(m, src)
}
func (m *InToto_ArtifactRule) XXX_Size() int {
	return xxx_messageInfo_InToto_ArtifactRule.Size(m)
}
func (m *InToto_ArtifactRule) XXX_DiscardUnknown() {
	xxx_messageInfo_InToto_ArtifactRule.DiscardUnknown(m)
}

var xxx_messageInfo_InToto_ArtifactRule proto.InternalMessageInfo

func (m *InToto_ArtifactRule) GetArtifactRule() []string {
	if m != nil {
		return m.ArtifactRule
	}
	return nil
}

// This defines the format used to record keys used in the software supply
// chain. An in-toto link is attested using one or more keys defined in the
// in-toto layout. An example of this is:
// {
//   "key_id": "776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b0...",
//   "key_type": "rsa",
//   "public_key_value": "-----BEGIN PUBLIC KEY-----\nMIIBojANBgkqhkiG9w0B...",
//   "key_scheme": "rsassa-pss-sha256"
// }
// The format for in-toto's key definition can be found in section 4.2 of the
// in-toto specification.
type SigningKey struct {
	// key_id is an identifier for the signing key.
	KeyId string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// This field identifies the specific signing method. Eg: "rsa", "ed25519",
	// and "ecdsa".
	KeyType string `protobuf:"bytes,2,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	// This field contains the actual public key.
	PublicKeyValue string `protobuf:"bytes,3,opt,name=public_key_value,json=publicKeyValue,proto3" json:"public_key_value,omitempty"`
	// This field contains the corresponding signature scheme.
	// Eg: "rsassa-pss-sha256".
	KeyScheme            string   `protobuf:"bytes,4,opt,name=key_scheme,json=keyScheme,proto3" json:"key_scheme,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SigningKey) Reset()         { *m = SigningKey{} }
func (m *SigningKey) String() string { return proto.CompactTextString(m) }
func (*SigningKey) ProtoMessage()    {}
func (*SigningKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{1}
}

func (m *SigningKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SigningKey.Unmarshal(m, b)
}
func (m *SigningKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SigningKey.Marshal(b, m, deterministic)
}
func (m *SigningKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningKey.Merge(m, src)
}
func (m *SigningKey) XXX_Size() int {
	return xxx_messageInfo_SigningKey.Size(m)
}
func (m *SigningKey) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningKey.DiscardUnknown(m)
}

var xxx_messageInfo_SigningKey proto.InternalMessageInfo

func (m *SigningKey) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *SigningKey) GetKeyType() string {
	if m != nil {
		return m.KeyType
	}
	return ""
}

func (m *SigningKey) GetPublicKeyValue() string {
	if m != nil {
		return m.PublicKeyValue
	}
	return ""
}

func (m *SigningKey) GetKeyScheme() string {
	if m != nil {
		return m.KeyScheme
	}
	return ""
}

// This corresponds to a signed in-toto link - it is made up of one or more
// signatures and the in-toto link itself. This is used for occurrences of a
// Grafeas in-toto note.
type Details struct {
	Signatures           []*Signature `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
	Link                 *Link        `protobuf:"bytes,2,opt,name=link,json=signed,proto3" json:"link,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Details) Reset()         { *m = Details{} }
func (m *Details) String() string { return proto.CompactTextString(m) }
func (*Details) ProtoMessage()    {}
func (*Details) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{2}
}

func (m *Details) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Details.Unmarshal(m, b)
}
func (m *Details) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Details.Marshal(b, m, deterministic)
}
func (m *Details) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Details.Merge(m, src)
}
func (m *Details) XXX_Size() int {
	return xxx_messageInfo_Details.Size(m)
}
func (m *Details) XXX_DiscardUnknown() {
	xxx_messageInfo_Details.DiscardUnknown(m)
}

var xxx_messageInfo_Details proto.InternalMessageInfo

func (m *Details) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *Details) GetLink() *Link {
	if m != nil {
		return m.Link
	}
	return nil
}

// A signature object consists of the KeyID used and the signature itself.
type Signature struct {
	KeyId                string   `protobuf:"bytes,1,opt,name=key_id,json=keyid,proto3" json:"key_id,omitempty"`
	Signature            string   `protobuf:"bytes,2,opt,name=signature,json=sig,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{3}
}

func (m *Signature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signature.Unmarshal(m, b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return xxx_messageInfo_Signature.Size(m)
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *Signature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// This corresponds to an in-toto link.
type Link struct {
	// This field contains the full command executed for the step. This can also
	// be empty if links are generated for operations that aren't directly mapped
	// to a specific command. Each term in the command is an independent string
	// in the list. An example of a command in the in-toto metadata field is:
	// "command": ["git", "clone", "https://github.com/in-toto/demo-project.git"]
	EffectiveCommand []string `protobuf:"bytes,1,rep,name=effective_command,json=command,proto3" json:"effective_command,omitempty"`
	// Materials are the supply chain artifacts that go into the step and are used
	// for the operation performed. The key of the map is the path of the artifact
	// and the structure contains the recorded hash information. An example is:
	// "materials": [
	//   {
	//     "resource_uri": "foo/bar",
	//     "hashes": {
	//       "sha256": "ebebf...",
	//       <OTHER HASH ALGORITHMS>: <HASH VALUE>
	//     }
	//   }
	// ]
	Materials []*Link_Artifact `protobuf:"bytes,2,rep,name=materials,proto3" json:"materials,omitempty"`
	// Products are the supply chain artifacts generated as a result of the step.
	// The structure is identical to that of materials.
	Products []*Link_Artifact `protobuf:"bytes,3,rep,name=products,proto3" json:"products,omitempty"`
	// ByProducts are data generated as part of a software supply chain step, but
	// are not the actual result of the step.
	Byproducts *Link_ByProducts `protobuf:"bytes,4,opt,name=byproducts,proto3" json:"byproducts,omitempty"`
	// This is a field that can be used to capture information about the
	// environment. It is suggested for this field to contain information that
	// details environment variables, filesystem information, and the present
	// working directory. The recommended structure of this field is:
	// "environment": {
	//   "custom_values": {
	//     "variables": "<ENV>",
	//     "filesystem": "<FS>",
	//     "workdir": "<CWD>",
	//     "<ANY OTHER RELEVANT FIELDS>": "..."
	//   }
	// }
	Environment          *Link_Environment `protobuf:"bytes,5,opt,name=environment,proto3" json:"environment,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{4}
}

func (m *Link) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Link.Unmarshal(m, b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Link.Marshal(b, m, deterministic)
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return xxx_messageInfo_Link.Size(m)
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetEffectiveCommand() []string {
	if m != nil {
		return m.EffectiveCommand
	}
	return nil
}

func (m *Link) GetMaterials() []*Link_Artifact {
	if m != nil {
		return m.Materials
	}
	return nil
}

func (m *Link) GetProducts() []*Link_Artifact {
	if m != nil {
		return m.Products
	}
	return nil
}

func (m *Link) GetByproducts() *Link_ByProducts {
	if m != nil {
		return m.Byproducts
	}
	return nil
}

func (m *Link) GetEnvironment() *Link_Environment {
	if m != nil {
		return m.Environment
	}
	return nil
}

// Defines a hash object for use in Materials and Products.
type Link_ArtifactHashes struct {
	Sha256               string   `protobuf:"bytes,1,opt,name=sha256,proto3" json:"sha256,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Link_ArtifactHashes) Reset()         { *m = Link_ArtifactHashes{} }
func (m *Link_ArtifactHashes) String() string { return proto.CompactTextString(m) }
func (*Link_ArtifactHashes) ProtoMessage()    {}
func (*Link_ArtifactHashes) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{4, 0}
}

func (m *Link_ArtifactHashes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Link_ArtifactHashes.Unmarshal(m, b)
}
func (m *Link_ArtifactHashes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Link_ArtifactHashes.Marshal(b, m, deterministic)
}
func (m *Link_ArtifactHashes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link_ArtifactHashes.Merge(m, src)
}
func (m *Link_ArtifactHashes) XXX_Size() int {
	return xxx_messageInfo_Link_ArtifactHashes.Size(m)
}
func (m *Link_ArtifactHashes) XXX_DiscardUnknown() {
	xxx_messageInfo_Link_ArtifactHashes.DiscardUnknown(m)
}

var xxx_messageInfo_Link_ArtifactHashes proto.InternalMessageInfo

func (m *Link_ArtifactHashes) GetSha256() string {
	if m != nil {
		return m.Sha256
	}
	return ""
}

type Link_Artifact struct {
	ResourceUri          string               `protobuf:"bytes,1,opt,name=resource_uri,json=resourceUri,proto3" json:"resource_uri,omitempty"`
	Hashes               *Link_ArtifactHashes `protobuf:"bytes,2,opt,name=hashes,proto3" json:"hashes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Link_Artifact) Reset()         { *m = Link_Artifact{} }
func (m *Link_Artifact) String() string { return proto.CompactTextString(m) }
func (*Link_Artifact) ProtoMessage()    {}
func (*Link_Artifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{4, 1}
}

func (m *Link_Artifact) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Link_Artifact.Unmarshal(m, b)
}
func (m *Link_Artifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Link_Artifact.Marshal(b, m, deterministic)
}
func (m *Link_Artifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link_Artifact.Merge(m, src)
}
func (m *Link_Artifact) XXX_Size() int {
	return xxx_messageInfo_Link_Artifact.Size(m)
}
func (m *Link_Artifact) XXX_DiscardUnknown() {
	xxx_messageInfo_Link_Artifact.DiscardUnknown(m)
}

var xxx_messageInfo_Link_Artifact proto.InternalMessageInfo

func (m *Link_Artifact) GetResourceUri() string {
	if m != nil {
		return m.ResourceUri
	}
	return ""
}

func (m *Link_Artifact) GetHashes() *Link_ArtifactHashes {
	if m != nil {
		return m.Hashes
	}
	return nil
}

// Defines an object for the byproducts field in in-toto links. The suggested
// fields are "stderr", "stdout", and "return-value".
type Link_ByProducts struct {
	CustomValues         map[string]string `protobuf:"bytes,1,rep,name=custom_values,json=customValues,proto3" json:"custom_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Link_ByProducts) Reset()         { *m = Link_ByProducts{} }
func (m *Link_ByProducts) String() string { return proto.CompactTextString(m) }
func (*Link_ByProducts) ProtoMessage()    {}
func (*Link_ByProducts) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{4, 2}
}

func (m *Link_ByProducts) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Link_ByProducts.Unmarshal(m, b)
}
func (m *Link_ByProducts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Link_ByProducts.Marshal(b, m, deterministic)
}
func (m *Link_ByProducts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link_ByProducts.Merge(m, src)
}
func (m *Link_ByProducts) XXX_Size() int {
	return xxx_messageInfo_Link_ByProducts.Size(m)
}
func (m *Link_ByProducts) XXX_DiscardUnknown() {
	xxx_messageInfo_Link_ByProducts.DiscardUnknown(m)
}

var xxx_messageInfo_Link_ByProducts proto.InternalMessageInfo

func (m *Link_ByProducts) GetCustomValues() map[string]string {
	if m != nil {
		return m.CustomValues
	}
	return nil
}

// Defines an object for the environment field in in-toto links. The suggested
// fields are "variables", "filesystem", and "workdir".
type Link_Environment struct {
	CustomValues         map[string]string `protobuf:"bytes,1,rep,name=custom_values,json=customValues,proto3" json:"custom_values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Link_Environment) Reset()         { *m = Link_Environment{} }
func (m *Link_Environment) String() string { return proto.CompactTextString(m) }
func (*Link_Environment) ProtoMessage()    {}
func (*Link_Environment) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{4, 3}
}

func (m *Link_Environment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Link_Environment.Unmarshal(m, b)
}
func (m *Link_Environment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Link_Environment.Marshal(b, m, deterministic)
}
func (m *Link_Environment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link_Environment.Merge(m, src)
}
func (m *Link_Environment) XXX_Size() int {
	return xxx_messageInfo_Link_Environment.Size(m)
}
func (m *Link_Environment) XXX_DiscardUnknown() {
	xxx_messageInfo_Link_Environment.DiscardUnknown(m)
}

var xxx_messageInfo_Link_Environment proto.InternalMessageInfo

func (m *Link_Environment) GetCustomValues() map[string]string {
	if m != nil {
		return m.CustomValues
	}
	return nil
}

func init() {
	proto.RegisterType((*InToto)(nil), "grafeas.v1beta1.intoto.InToto")
	proto.RegisterType((*InToto_ArtifactRule)(nil), "grafeas.v1beta1.intoto.InToto.ArtifactRule")
	proto.RegisterType((*SigningKey)(nil), "grafeas.v1beta1.intoto.SigningKey")
	proto.RegisterType((*Details)(nil), "grafeas.v1beta1.intoto.Details")
	proto.RegisterType((*Signature)(nil), "grafeas.v1beta1.intoto.Signature")
	proto.RegisterType((*Link)(nil), "grafeas.v1beta1.intoto.Link")
	proto.RegisterType((*Link_ArtifactHashes)(nil), "grafeas.v1beta1.intoto.Link.ArtifactHashes")
	proto.RegisterType((*Link_Artifact)(nil), "grafeas.v1beta1.intoto.Link.Artifact")
	proto.RegisterType((*Link_ByProducts)(nil), "grafeas.v1beta1.intoto.Link.ByProducts")
	proto.RegisterMapType((map[string]string)(nil), "grafeas.v1beta1.intoto.Link.ByProducts.CustomValuesEntry")
	proto.RegisterType((*Link_Environment)(nil), "grafeas.v1beta1.intoto.Link.Environment")
	proto.RegisterMapType((map[string]string)(nil), "grafeas.v1beta1.intoto.Link.Environment.CustomValuesEntry")
}

func init() { proto.RegisterFile("intoto.proto", fileDescriptor_1442eade79a66571) }

var fileDescriptor_1442eade79a66571 = []byte{
	// 733 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x6e, 0xf3, 0x44,
	0x14, 0x95, 0xe3, 0xc4, 0x8d, 0x6f, 0xd2, 0x92, 0x8e, 0xa0, 0x72, 0x43, 0x91, 0xd2, 0x20, 0x44,
	0x50, 0x25, 0x57, 0x4d, 0x05, 0x2a, 0xdd, 0xa0, 0x34, 0x54, 0xa5, 0x94, 0x9f, 0xca, 0x2d, 0x08,
	0x75, 0x81, 0x35, 0xb1, 0x6f, 0x92, 0x91, 0xff, 0xa2, 0x99, 0x71, 0x84, 0x77, 0xec, 0x78, 0x0d,
	0xc4, 0x1e, 0xf1, 0x18, 0xbc, 0x16, 0xf2, 0x6f, 0x2c, 0xd1, 0x46, 0xed, 0xe2, 0x5b, 0xc5, 0x73,
	0x7c, 0xce, 0xf1, 0xcd, 0xb9, 0xc7, 0x09, 0x74, 0x59, 0x28, 0x23, 0x19, 0x99, 0x2b, 0x1e, 0xc9,
	0x88, 0x1c, 0x2c, 0x38, 0x9d, 0x23, 0x15, 0xe6, 0xfa, 0x6c, 0x86, 0x92, 0x9e, 0x99, 0xf9, 0xdd,
	0xe1, 0x9f, 0x2a, 0x68, 0xb7, 0xe1, 0x63, 0x4a, 0xf9, 0x10, 0x74, 0x21, 0x71, 0x65, 0x87, 0x34,
	0x40, 0x43, 0x19, 0x28, 0x23, 0xdd, 0x6a, 0xa7, 0xc0, 0x0f, 0x34, 0x40, 0x72, 0x0d, 0x5d, 0xc1,
	0x16, 0x21, 0x0b, 0x17, 0xb6, 0x87, 0x89, 0x30, 0x1a, 0x03, 0x75, 0xd4, 0x19, 0x0f, 0xcd, 0xe7,
	0x6d, 0xcd, 0x87, 0x9c, 0x7b, 0x87, 0x89, 0xd5, 0x11, 0xd5, 0xb5, 0x20, 0x4f, 0x40, 0xf0, 0xb7,
	0x15, 0x3a, 0x12, 0x5d, 0x3b, 0xa0, 0x12, 0x39, 0xa3, 0xbe, 0x30, 0xd4, 0xcc, 0xec, 0xe4, 0x25,
	0xb3, 0x7c, 0x3e, 0x73, 0xc2, 0x25, 0x9b, 0x53, 0x47, 0x5a, 0xb1, 0x8f, 0xd6, 0x7e, 0x69, 0xf3,
	0x7d, 0xe9, 0x42, 0x7e, 0x81, 0x0a, 0xb4, 0x57, 0x3c, 0x72, 0x63, 0x47, 0x0a, 0xa3, 0xf9, 0x76,
	0xeb, 0x5e, 0xe9, 0x72, 0x5f, 0x98, 0x90, 0xcf, 0xa0, 0xc2, 0x6c, 0x27, 0x0a, 0x02, 0x1a, 0xba,
	0x46, 0x6b, 0xa0, 0x8e, 0x74, 0xeb, 0xbd, 0x12, 0x9f, 0xe6, 0x30, 0x39, 0x02, 0x5d, 0x2e, 0x39,
	0x8a, 0x65, 0xe4, 0xbb, 0x86, 0x36, 0x50, 0x46, 0xaa, 0xb5, 0x01, 0xfa, 0xe7, 0xd0, 0xad, 0x3f,
	0x8a, 0x7c, 0x0c, 0xbb, 0xb4, 0x38, 0xdb, 0x3c, 0xf6, 0xd3, 0xd8, 0x53, 0xd7, 0x2e, 0xad, 0x91,
	0x86, 0x7f, 0x28, 0x00, 0x9b, 0x3c, 0xc9, 0x07, 0xa0, 0x79, 0x98, 0xd8, 0xcc, 0x2d, 0x76, 0xd4,
	0xf2, 0x30, 0xb9, 0x75, 0xc9, 0x21, 0xb4, 0x53, 0x58, 0x26, 0x2b, 0x34, 0x1a, 0xd9, 0x8d, 0x1d,
	0x0f, 0x93, 0xc7, 0x64, 0x85, 0x64, 0x04, 0xbd, 0x55, 0x3c, 0xf3, 0x99, 0x93, 0xae, 0xce, 0x5e,
	0x53, 0x3f, 0x46, 0x43, 0xcd, 0x28, 0x7b, 0x39, 0x7e, 0x87, 0xc9, 0xcf, 0x29, 0x4a, 0x3e, 0x02,
	0x48, 0x29, 0xc2, 0x59, 0x62, 0x80, 0x46, 0x33, 0xe3, 0xe8, 0x1e, 0x26, 0x0f, 0x19, 0x30, 0xfc,
	0x5d, 0x81, 0x9d, 0xaf, 0x51, 0x52, 0xe6, 0x0b, 0x32, 0x01, 0x48, 0x17, 0x4b, 0x65, 0xcc, 0x51,
	0x64, 0x73, 0x77, 0xc6, 0xc7, 0xdb, 0xea, 0x90, 0x31, 0xad, 0x9a, 0x88, 0x8c, 0xa1, 0xe9, 0xb3,
	0xd0, 0xcb, 0xc6, 0xed, 0x8c, 0x8f, 0x5e, 0x12, 0x7f, 0xc7, 0x42, 0xcf, 0xd2, 0x52, 0x1d, 0xba,
	0xc3, 0x4b, 0xd0, 0x2b, 0xb3, 0x67, 0xa3, 0x60, 0x2e, 0x39, 0x00, 0xbd, 0x7a, 0x4a, 0x91, 0x85,
	0x2a, 0xd8, 0x62, 0xf8, 0xaf, 0x06, 0xcd, 0xd4, 0x8c, 0x0c, 0x61, 0x1f, 0xe7, 0x73, 0x74, 0x24,
	0x5b, 0x63, 0xb5, 0xd0, 0x3c, 0xfa, 0x9d, 0xe2, 0x48, 0xa6, 0xa0, 0x6f, 0x0a, 0x9a, 0xb7, 0xfd,
	0x93, 0x6d, 0x13, 0x6e, 0x3a, 0xb4, 0xd1, 0x91, 0x09, 0xb4, 0xab, 0x26, 0xaa, 0x6f, 0xf1, 0xa8,
	0x64, 0xe4, 0x06, 0x60, 0x96, 0xd4, 0xea, 0x9c, 0x46, 0xf5, 0xe9, 0x56, 0x93, 0xab, 0xa4, 0x2c,
	0xae, 0x55, 0x93, 0x92, 0x6f, 0xa1, 0x83, 0xe1, 0x9a, 0xf1, 0x28, 0x0c, 0x30, 0x94, 0x46, 0x2b,
	0x73, 0x1a, 0x6d, 0x75, 0xba, 0xde, 0xf0, 0xad, 0xba, 0xb8, 0x3f, 0x82, 0xbd, 0x72, 0xd4, 0x6f,
	0xa8, 0x58, 0xa2, 0x20, 0x07, 0xa0, 0x89, 0x25, 0x1d, 0x7f, 0xfe, 0x45, 0xb1, 0x8a, 0xe2, 0xd4,
	0xe7, 0xd0, 0x2e, 0x99, 0xe4, 0x18, 0xba, 0x1c, 0x45, 0x14, 0x73, 0x07, 0xed, 0x98, 0xb3, 0x82,
	0xd9, 0x29, 0xb1, 0x9f, 0x38, 0x23, 0x53, 0xd0, 0x96, 0x99, 0x61, 0x51, 0x8a, 0x93, 0x57, 0xc5,
	0x95, 0xcf, 0x60, 0x15, 0xd2, 0xfe, 0xdf, 0x0a, 0xc0, 0x26, 0x04, 0xf2, 0x2b, 0xec, 0x3a, 0xb1,
	0x90, 0x51, 0x90, 0x57, 0xbf, 0x2c, 0xeb, 0x97, 0xaf, 0x0c, 0xd1, 0x9c, 0x66, 0xe2, 0xec, 0x05,
	0x11, 0xd7, 0xa1, 0xe4, 0x89, 0xd5, 0x75, 0x6a, 0x50, 0xff, 0x2b, 0xd8, 0xff, 0x1f, 0x85, 0xf4,
	0x40, 0xf5, 0x30, 0x29, 0xbe, 0x62, 0x7a, 0x49, 0xde, 0x87, 0x56, 0xfe, 0xea, 0xe5, 0x8d, 0xcc,
	0x0f, 0x97, 0x8d, 0x0b, 0xa5, 0xff, 0x8f, 0x02, 0x9d, 0x5a, 0xd4, 0xc4, 0x7e, 0x7e, 0xe0, 0xcb,
	0xd7, 0xee, 0xea, 0x9d, 0x4f, 0x7c, 0x15, 0xc1, 0x21, 0x8b, 0x5e, 0x18, 0xe7, 0xaa, 0x97, 0xff,
	0xa8, 0xfe, 0x18, 0x4b, 0xe4, 0x53, 0x9f, 0x0a, 0x71, 0xaf, 0x3c, 0x5d, 0x2c, 0x98, 0x5c, 0xc6,
	0x33, 0xd3, 0x89, 0x82, 0xd3, 0x42, 0x56, 0x7d, 0x66, 0x7f, 0x50, 0xa7, 0x85, 0xc9, 0x69, 0x6e,
	0x62, 0x2f, 0x22, 0x3b, 0xc3, 0xff, 0x6a, 0xa8, 0x37, 0xd6, 0x64, 0xa6, 0x65, 0x87, 0xf3, 0xff,
	0x02, 0x00, 0x00, 0xff, 0xff, 0x2b, 0x03, 0x36, 0xbe, 0xd5, 0x06, 0x00, 0x00,
}
